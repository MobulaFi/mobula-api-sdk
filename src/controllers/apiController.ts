/**
 * MobulaLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { ErrorResponseError } from '../errors/errorResponseError';
import { AllResponse, allResponseSchema } from '../models/allResponse';
import { Asset, assetSchema } from '../models/asset';
import {
  MarketDataResponse,
  marketDataResponseSchema,
} from '../models/marketDataResponse';
import {
  MarketHistoryResponse,
  marketHistoryResponseSchema,
} from '../models/marketHistoryResponse';
import {
  MarketPairResponse,
  marketPairResponseSchema,
} from '../models/marketPairResponse';
import {
  MarketPairsResponse,
  marketPairsResponseSchema,
} from '../models/marketPairsResponse';
import {
  MultiDataResponse,
  multiDataResponseSchema,
} from '../models/multiDataResponse';
import { OrderEnum, orderEnumSchema } from '../models/orderEnum';
import { QuoteResponse1, quoteResponse1Schema } from '../models/quoteResponse1';
import { SearchResponse, searchResponseSchema } from '../models/searchResponse';
import {
  TradeHistoryResponse,
  tradeHistoryResponseSchema,
} from '../models/tradeHistoryResponse';
import { TypeEnum, typeEnumSchema } from '../models/typeEnum';
import {
  WalletHistoryResponse,
  walletHistoryResponseSchema,
} from '../models/walletHistoryResponse';
import {
  WalletNftsResponse1,
  walletNftsResponse1Schema,
} from '../models/walletNftsResponse1';
import {
  WalletPortfolioResponse1,
  walletPortfolioResponse1Schema,
} from '../models/walletPortfolioResponse1';
import {
  WalletTransactionsResponse,
  walletTransactionsResponseSchema,
} from '../models/walletTransactionsResponse';
import { bigint, boolean, number, optional, string, unknown } from '../schema';
import { BaseController } from './baseController';

export class ApiController extends BaseController {
  /**
   * @param name Name or symbol (or starting name/symbol) of the asset
   * @return Response from the API call
   */
  async searchCryptoByName(
    name?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SearchResponse>> {
    const req = this.createRequest('GET', '/search');
    const mapped = req.prepareArgs({ name: [name, optional(string())] });
    req.query('name', mapped.name);
    return req.callAsJson(searchResponseSchema, requestOptions);
  }

  /**
   * @param wallet      Wallet address or ENS or Mobula username
   * @param force       Will force a new on-chain data fetch
   * @param blockchains Blockchains to fetch NFTs from (by default, all) - comma separated, chain ID or
   *                               chain name
   * @return Response from the API call
   */
  async fetchWalletNFTs(
    wallet?: string,
    force?: boolean,
    blockchains?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<WalletNftsResponse1>> {
    const req = this.createRequest('GET', '/wallet/nfts');
    const mapped = req.prepareArgs({
      wallet: [wallet, optional(string())],
      force: [force, optional(boolean())],
      blockchains: [blockchains, optional(string())],
    });
    req.query('wallet', mapped.wallet);
    req.query('force', mapped.force);
    req.query('blockchains', mapped.blockchains);
    return req.callAsJson(walletNftsResponse1Schema, requestOptions);
  }

  /**
   * @param fields Extra fields needed
   * @return Response from the API call
   */
  async fetchAllCryptoDetails(
    fields?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<AllResponse>> {
    const req = this.createRequest('GET', '/all');
    const mapped = req.prepareArgs({ fields: [fields, optional(string())] });
    req.query('fields', mapped.fields);
    return req.callAsJson(allResponseSchema, requestOptions);
  }

  /**
   * @param asset      The asset you want to target - asset name only works for assets listed on Mobula.
   * @param blockchain Blockchain of the asset - only mandatory if asset is sent as smart-contract.
   * @param symbol     Symbol of the asset - only mandatory if no asset name/contract is provided
   * @return Response from the API call
   */
  async fetchAssetMarketData(
    asset?: string,
    blockchain?: string,
    symbol?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MarketDataResponse>> {
    const req = this.createRequest('GET', '/market/data');
    const mapped = req.prepareArgs({
      asset: [asset, optional(string())],
      blockchain: [blockchain, optional(string())],
      symbol: [symbol, optional(string())],
    });
    req.query('asset', mapped.asset);
    req.query('blockchain', mapped.blockchain);
    req.query('symbol', mapped.symbol);
    return req.callAsJson(marketDataResponseSchema, requestOptions);
  }

  /**
   * @param address    The address of the smart-contract of the pair (or pool, or vault).
   * @param blockchain Blockchain of the pair (only mandatory for Balancer V2 pairs).
   * @param asset      The name/address of the asset you want in return
   * @return Response from the API call
   */
  async fetchPairMarketData(
    address: string,
    blockchain?: string,
    asset?: unknown,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MarketPairResponse>> {
    const req = this.createRequest('GET', '/market/pair');
    const mapped = req.prepareArgs({
      address: [address, string()],
      blockchain: [blockchain, optional(string())],
      asset: [asset, optional(unknown())],
    });
    req.query('address', mapped.address);
    req.query('blockchain', mapped.blockchain);
    req.query('asset', mapped.asset as string);
    return req.callAsJson(marketPairResponseSchema, requestOptions);
  }

  /**
   * @param asset      The asset you want to target - asset name only works for assets listed on Mobula.
   * @param blockchain Blockchain of the asset - only mandatory if asset is sent as smart-contract.
   * @param offset     The offset of the results
   * @return Response from the API call
   */
  async fetchPairsMarketData(
    asset: string,
    blockchain?: string,
    offset?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MarketPairsResponse>> {
    const req = this.createRequest('GET', '/market/pairs');
    const mapped = req.prepareArgs({
      asset: [asset, string()],
      blockchain: [blockchain, optional(string())],
      offset: [offset, optional(number())],
    });
    req.query('asset', mapped.asset);
    req.query('blockchain', mapped.blockchain);
    req.query('offset', mapped.offset);
    return req.callAsJson(marketPairsResponseSchema, requestOptions);
  }

  /**
   * @param asset      The asset you want to target - asset name only works for assets listed on Mobula.
   * @param blockchain Blockchain of the asset - only mandatory if asset is sent as smart-contract.
   * @param from       JS Timestamp (milliseconds) of the beginning of the timeframe (if not provided,
   *                             genesis)
   * @param to         JS Timestamp (milliseconds) of the end of the timeframe (if not provided, end)
   * @return Response from the API call
   */
  async fetchAssetMarketHistory(
    asset: string,
    blockchain?: string,
    from?: number,
    to?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MarketHistoryResponse>> {
    const req = this.createRequest('GET', '/market/history');
    const mapped = req.prepareArgs({
      asset: [asset, string()],
      blockchain: [blockchain, optional(string())],
      from: [from, optional(number())],
      to: [to, optional(number())],
    });
    req.query('asset', mapped.asset);
    req.query('blockchain', mapped.blockchain);
    req.query('from', mapped.from);
    req.query('to', mapped.to);
    return req.callAsJson(marketHistoryResponseSchema, requestOptions);
  }

  /**
   * @param assets      Comma separated list of asset names or Ethereum addresses (max 500)
   * @param blockchains Comma separated list of blockchain names
   * @param symbols     Comma separated list of symbols
   * @return Response from the API call
   */
  async fetchMultipleAssetMarketData(
    assets?: string,
    blockchains?: string,
    symbols?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<MultiDataResponse>> {
    const req = this.createRequest('GET', '/market/multi-data');
    const mapped = req.prepareArgs({
      assets: [assets, optional(string())],
      blockchains: [blockchains, optional(string())],
      symbols: [symbols, optional(string())],
    });
    req.query('assets', mapped.assets);
    req.query('blockchains', mapped.blockchains);
    req.query('symbols', mapped.symbols);
    req.throwOn(400, ErrorResponseError, 'Bad request response.');
    return req.callAsJson(multiDataResponseSchema, requestOptions);
  }

  /**
   * @param asset      Asset name or contract address to retrieve trade history for.
   * @param maxResults Maximum number of results to return.
   * @return Response from the API call
   */
  async fetchAssetTradeHistory(
    asset: string,
    maxResults?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<TradeHistoryResponse>> {
    const req = this.createRequest('GET', '/market/trades');
    const mapped = req.prepareArgs({
      asset: [asset, string()],
      maxResults: [maxResults, optional(number())],
    });
    req.query('asset', mapped.asset);
    req.query('maxResults', mapped.maxResults);
    req.throwOn(400, ErrorResponseError, 'Bad request (e.g., missing asset parameter)');
    return req.callAsJson(tradeHistoryResponseSchema, requestOptions);
  }

  /**
   * @param asset      Name or contract address of the asset
   * @param blockchain Blockchain of the asset
   * @return Response from the API call
   */
  async fetchAssetMetadata(
    asset: string,
    blockchain?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Asset>> {
    const req = this.createRequest('GET', '/metadata');
    const mapped = req.prepareArgs({
      asset: [asset, string()],
      blockchain: [blockchain, optional(string())],
    });
    req.query('asset', mapped.asset);
    req.query('blockchain', mapped.blockchain);
    return req.callAsJson(assetSchema, requestOptions);
  }

  /**
   * @param chain       Blockchain of the trade
   * @param fromToken   Source token for the swap
   * @param toToken     Destination token for the swap
   * @param fromAddress Address that triggers the trade
   * @param amount      Amount (x decimals) for the swap in
   * @param slippage    Slippage (%) accepted
   * @param receiver    Address that receives the trade (by default, the sender)
   * @param type        Aggregation type (fast or best)
   * @return Response from the API call
   */
  async fetchSwapQuote(
    chain: string,
    fromToken: string,
    toToken: string,
    fromAddress: string,
    amount: bigint,
    slippage: number,
    receiver?: string,
    type?: TypeEnum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<QuoteResponse1>> {
    const req = this.createRequest('GET', '/quote');
    const mapped = req.prepareArgs({
      chain: [chain, string()],
      fromToken: [fromToken, string()],
      toToken: [toToken, string()],
      fromAddress: [fromAddress, string()],
      amount: [amount, bigint()],
      slippage: [slippage, number()],
      receiver: [receiver, optional(string())],
      type: [type, optional(typeEnumSchema)],
    });
    req.query('chain', mapped.chain);
    req.query('fromToken', mapped.fromToken);
    req.query('toToken', mapped.toToken);
    req.query('fromAddress', mapped.fromAddress);
    req.query('amount', mapped.amount);
    req.query('slippage', mapped.slippage);
    req.query('receiver', mapped.receiver);
    req.query('type', mapped.type);
    return req.callAsJson(quoteResponse1Schema, requestOptions);
  }

  /**
   * @param wallet      The user wallet queried
   * @param from        JS Timestamp (miliseconds) of the beginning of the timeframe (if not provided,
   *                              genesis)
   * @param to          JS Timestamp (miliseconds) of the end of the timeframe (if not provided, end)
   * @param blockchains Blockchains to fetch history from (by default, all) - comma separated, chain ID or
   *                              chain name
   * @return Response from the API call
   */
  async fetchWalletHistoryBalance(
    wallet: string,
    from?: number,
    to?: number,
    blockchains?: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<WalletHistoryResponse>> {
    const req = this.createRequest('GET', '/wallet/history');
    const mapped = req.prepareArgs({
      wallet: [wallet, string()],
      from: [from, optional(number())],
      to: [to, optional(number())],
      blockchains: [blockchains, optional(string())],
    });
    req.query('wallet', mapped.wallet);
    req.query('from', mapped.from);
    req.query('to', mapped.to);
    req.query('blockchains', mapped.blockchains);
    return req.callAsJson(walletHistoryResponseSchema, requestOptions);
  }

  /**
   * Get the portfolio of holdings from any EVM-compatible wallets, at any time
   *
   * @param wallet      The user wallet queried
   * @param blockchains Blockchains to fetch holdings from (by default, all) - comma separated, chain ID or
   *                               chain name
   * @param cache       Will use cached data if available
   * @param stale       Amount of seconds after which the cache is considered stale (default 5min)
   * @return Response from the API call
   */
  async fetchWalletHoldings(
    wallet: string,
    blockchains?: string,
    cache?: boolean,
    stale?: number,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<WalletPortfolioResponse1>> {
    const req = this.createRequest('GET', '/wallet/portfolio');
    const mapped = req.prepareArgs({
      wallet: [wallet, string()],
      blockchains: [blockchains, optional(string())],
      cache: [cache, optional(boolean())],
      stale: [stale, optional(number())],
    });
    req.query('wallet', mapped.wallet);
    req.query('blockchains', mapped.blockchains);
    req.query('cache', mapped.cache);
    req.query('stale', mapped.stale);
    return req.callAsJson(walletPortfolioResponse1Schema, requestOptions);
  }

  /**
   * Retrieve all transactions for a specified wallet within a given timeframe.
   *
   * @param wallet      The user wallet queried
   * @param from        Start of the timeframe for transactions (timestamp)
   * @param to          End of the timeframe for transactions (timestamp)
   * @param asset       Specific asset to filter transactions
   * @param blockchains Blockchains to fetch NFTs from (by default, all) - comma separated, chain ID or
   *                                 chain name
   * @param limit       Number of transactions to return per page
   * @param offset      Number of transactions to skip
   * @param order       Example: asc
   * @return Response from the API call
   */
  async fetchWalletTransactions(
    wallet: string,
    from?: number,
    to?: number,
    asset?: string,
    blockchains?: string,
    limit?: number,
    offset?: number,
    order?: OrderEnum,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<WalletTransactionsResponse>> {
    const req = this.createRequest('GET', '/wallet/transactions');
    const mapped = req.prepareArgs({
      wallet: [wallet, string()],
      from: [from, optional(number())],
      to: [to, optional(number())],
      asset: [asset, optional(string())],
      blockchains: [blockchains, optional(string())],
      limit: [limit, optional(number())],
      offset: [offset, optional(number())],
      order: [order, optional(orderEnumSchema)],
    });
    req.query('wallet', mapped.wallet);
    req.query('from', mapped.from);
    req.query('to', mapped.to);
    req.query('asset', mapped.asset);
    req.query('blockchains', mapped.blockchains);
    req.query('limit', mapped.limit);
    req.query('offset', mapped.offset);
    req.query('order', mapped.order);
    return req.callAsJson(walletTransactionsResponseSchema, requestOptions);
  }
}
